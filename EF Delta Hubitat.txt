/***
 ***********************  ECOFLOW DELTA PRO / DELTA 2 SERIES MQTT HUBITAT DRIVER -   ***************************************
 *               	 
 *  Driver has been tested on DeltaPro and Delta 2 Batteries. Some functions may work with the EF River series, but more
 *  testing and debugging are required.
 *          	 
 *                     	 
 *  D. Dimond 01/31/2023
 *  Hubitat @daryl678
 *
 *  Design Usage:
 *  This driver is designed to control Ecowflow battery models Delta 2, Delta pro, and River.  
 *  The driver will create child switches based on the model. The Delta2: AC, DC, & USB. The Delta Pro: AC & DC. The River
 *  AC, DC, and LED light.
 *    
 *  	 
 *  There is a lot of battery data - The Driver loads a small collection to current device states - There are built-in tools 
 *   for tracking additional data points.
 *  1. All device states are loaded when debug is active
 *  2. A deltflag will display changes in device states to the log file when debug is active
 *  This can help track down additional attributes that can be manually added to the attribute def and ProcessEvent code lines.
 *
 *
 *************************************** Special Instructions ******************************************************************
 *  A procedure is required to obtain your MQTT access keys. See GitHub folder for MQTT key instructions to obtain your MQTT   *
 *  keys. Or follow this link to grab the instructions:                                                                        *
 *  https://github.com/darryl678/darryl678/blob/Hubitat-EF-Delta-Driver/Accessing-EF-.docx                                    *
 *********************************************************** *******************************************************************           
 *   
 *  This driver does not support the deletion of child devices. If changing the battery model after initialization clear child
 *  devices out manually by loading your device with the internal Hubitat driver called DEVICE and clear out child devices.
 *   
 *  
 *  Thank You(s)
 *  Mark H. - for helping me get mqtt explorer connected to my battery. That was the starting point.
 *  @shircliffs for giving me control of his Delta Pro to test functions and figure out variable names
 *  @steve101 for providing Delta Pro model parameters
 *  @ronv42 for providing River Parameters and driver path discussions
 *  @snell for always taking the time to give detailed responses to my never-ending coding questions.
 *
 * ------------------------------------------------------------------------------------------------------------------------------
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *
 *
 *  Changes: 
 *    0.1.3 02/09/23     Fixed more mapping errors on DP series - Added AlwaysON child switch - fix bug eith state variable loading
 *    0.1.2 02/08/23     Fixed mapping errors on DP series - roughed in Alwayson feature needs testing
 *    0.1.0 01/31/2023 - Released for Delta2 and Deltapro - River Battery Model release pending
 *    0.1.1 02/03/2023   Added mqtt status of "online" & "OFFLINE" to deviceâ€™s current states
 *                       Added mqtt disconnect command
 *                       Added code below to reduce events on updates:
 *                       1. Added code to reduce event update loads when using refresh time under 60 sec
 *                       2. Added feature to update all current device states every X scans to catch any missed "isstatgechanged" flags
 *                       3. Removed decimals from attributes to reduce event loading due to small changes in values
 *                       4. The full list of battery variables is only updated to states variables when debug is active
 *                       5. The feature to log changes to state variables is only active when debug is active.
 *                       Added "Battery Status" attribute string showing battery time remaining in HH:MM format   
 *                       Added RunRequest() block to reduce repetitive program code
 *                       Fixed XBoost Child switch on/off function  
 *
 */


import groovy.json.JsonSlurper;

metadata {
  definition(name: "EcoFlow Battery mqtt", namespace: "EFmqtt2", author: "Darryl Dimond", importURL: "not listed") {
    capability "Initialize"
    capability "Actuator"
    capability "Battery"
    capability "PowerMeter"
    capability "TemperatureMeasurement"
    command "ACSwitchON"
    command "ACSwitchOFF"
    command "DCSwitchON"
    command "DCSwitchOFF"
    command "USBSwitchON"
    command "USBSwitchOFF"
    command "LEDSwitchON"
    command "LEDSwitchOFF"
    command "XBoostON"
    command "XBoostOFF"
    command "PowerUpAcON"
    command "PowerUpAcOFF"
    command "Disconnect"
    command "refreshdata"
    command "LimitWattsCharging" , ["number"]
    command "LimitDischarge", ["number"]
    command "LimitCharge", ["number"]
    command "SmartGenAutoOFF" , ["number"]
    command "SmartGenAutoON", ["number"]
    command "LimitCarInput" , ["number"]
    command "TimeOutUnit" , ["number"]
    command "TimeOutScreen",["number"]
    command "TimeoutACOutput",["number"]
    command "TimeoutDCOutput",["number"]

    attribute "Cycles on Master", "number"
    attribute "Cycles on Slave", "number"
    attribute "Output Status AC", "number"
    attribute "Output Status DC", "number"
    attribute "Output Status USB", "number"
    attribute "Output Status LED", "number"
    attribute "Output XBoost" , "number"
    attribute "Fault Code mppt", "number"
    attribute "Fault Master Cell", "number"
    attribute "Fault Slave Cell", "number"
    attribute "SOC Master Cell", "number"
    attribute "SOC Master Display", "number"
    attribute "SOC Slave Cell", "number"
    attribute "SOC Slave Display", "number"
    attribute "Temp DC", "number"
    attribute "Temp Mppt", "number"
    attribute "Temp Master Cell", "number"
    attribute "Temp Slave Cell", "number"
    attribute "Temp Inverter Out", "number"
    attribute "Temp Inverter In", "number"
    attribute "Time Remain", "number"
    attribute "Battery Status", "string"
 //  attribute "Time Remain Slave", "number"
 //  attribute "Time Remain Display", "number"
    attribute "Watts DC Out", "number"
    attribute "Watts AC In", "number"
    attribute "Watts AC Out", "number"
    attribute "Watts Slave In", "number"
    attribute "Watts Slave Out", "number"
    attribute "Last Update", "string"
    attribute "htmlTile1", "string"
    attribute "Limit Charging Rate", "number"
    attribute "Limit Discharge", "number"
    attribute "Limit Charge" , "number"
    attribute "SmartGen Off Point", "number"
    attribute "SmartGen On Point" , "number"   
    attribute "Limit CarCharge Amps" , "number"
    attribute "TimeOut Unit" , "number" 
    attribute "TimeOut Screen" , "number" 
    attribute "Timeout AC Output" , "number" 
    attribute "Timeout DC Output" , "number" 
    attribute "DC Charging Watts" , "number"  
    attribute "mqtt Status" , "string"
    attribute "AC Always On" , "number"
  }

  preferences {
    input name: "unitserialno", type: "text", title: "serial number of unit:", required: true, displayDuringSetup: true
    input name: "mqttclientname", type: "text", title: "mqttclientname:", required: true, displayDuringSetup: true
    input name: "MQTTBroker", type: "text", title: "MQTT Broker Address:", required: true, displayDuringSetup: true, defaultValue: "mqtt.ecoflow.com"
    input name: "username", type: "text", title: "MQTT Username:", description: "(blank if none)", required: false, displayDuringSetup: true
    input name: "password", type: "password", title: "MQTT Password:", description: "(blank if none)", required: false, displayDuringSetup: true
    input name: "EFmodel", type: "text", title: "EF model:", description: "options are delta2 deltapro or river - no caps", required: true, displayDuringSetup: true, defaultValue: "delta"
    input name: "tempF", type: "text", title: "Temp in C or F:", description: "type C or F", required: true, displayDuringSetup: true, defaultValue: "C"
    input("logEnable", "bool", title: "Enable logging", required: true, defaultValue: true)
    input name: "updateTime", type: "number", title: "Background Data Refresh Rate (Seconds) 60 recommended - minimum is 15", required: false, defaultValue: 60, displayDuringSetup: true
    input name: "allrefresh", type: "number", title: "Number of changed only updates before all current states are updated", required: true, defaultValue: 5, displayDuringSetup: true
    input(name: "htmlTemplate1", type: "string", title: "<b>Tile Template</b>", description: "<font size='2'>Ex: [b]Remaining Minutes:[/b] \${ remainMins }V[/br]</font>", defaultValue: "");
  }

}

def installed() {
  initialize()
}

// Parse incoming device messages to generate events
def parse(String description) {
  log.info "Updating " + EFmodel + " data"
  runIn(state.SetUpdateTime, refreshdata)
  Date date = new Date();
  topic = interfaces.mqtt.parseMessage(description).topic
  topic = topic.substring(topic.lastIndexOf("/") + 1)
  payload = interfaces.mqtt.parseMessage(description).payload
  def jsonSlurper = new JsonSlurper()
  def jsonpl = jsonSlurper.parseText(payload)
  if (logEnable) log.debug payload
  def jsonObject = new JsonSlurper().parseText(payload)
  if (logEnable) log.info "updating current states"
  // scan through each JSON point - Process data 
  jsonpl.data.quotaMap.each {
     if (logEnable  || state.firstrun == 0 ) {
        if (state."${ it.key }" != it.value) {
           oldstatevar = state."${ it.key }"
           state."${ it.key }" = it.value // load all the state values for display in device states
           log.info "Battery variable>>" + it.key + "<< old value:* " + oldstatevar + " NEW VALUE: *** " + it.value  //flag battery variable changes to info log
        }
     }
  }
  state.firstrun = 1   
  if (tempF == "F") { //check if temp request is C or F
    mul = 9 / 5
    adder = 32
    tunit = "F"
  } else {
    mul = 1
    adder = 0
    tunit = "C"
  }
  timerm = jsonpl.data.quotaMap."pd.remainTime"
  Integer timermHR = timerm / 60
  Integer timermMIN = timerm - timermHR * 60
  BatteryStatus = timermHR + ":" + timermMIN
  if (BatteryStatus != state.tbs ) {
    sendEvent(name: "Battery Status", value: BatteryStatus, isStateChanged: false )
    state.tbs = BatteryStatus
  }
 // Get JSON varaible for device outputs - case by model
  switch (EFmodel) {
     case "delta2": 
       // log.info "Loading Delta 2 Data Map"
       ACOutput_Enabled = jsonpl.data.quotaMap."inv.cfgAcEnabled"
       DCOutput_Enabled = jsonpl.data.quotaMap."mppt.carState"
       USBOutput_Enabled = jsonpl.data.quotaMap."pd.dcOutState"
       LEDOutput_Enabled = null
       XBoost_Enabled = jsonpl.data.quotaMap."mppt.cfgAcXboost"
       AcAlways_Enabled = jsonpl.data.quotaMap."inv.acPassByAutoEn"
       sendEvent(name: "power", value: jsonpl.data.quotaMap."inv.outputWatts", unit: "w", isStateChanged: true )
       Integer ttemp = jsonpl.data.quotaMap."bms_bmsStatus.temp" * mul + adder 
       sendEvent(name: "temperature", value: ttemp, unit: tunit, isStateChanged: true )
       sendEvent(name: "battery", value: jsonpl.data.quotaMap."bms_emsStatus.lcdShowSoc", unit: "%", isStateChanged: true )
       ProcessEvent( "Output Status AC", jsonpl.data.quotaMap."inv.cfgAcEnabled", null, true )
       ProcessEvent( "Output Status DC" , jsonpl.data.quotaMap."mppt.carState", null, true )
       ProcessEvent( "Output Status USB" , jsonpl.data.quotaMap."pd.dcOutState", null, true )
       ProcessEvent( "Output Status LED" , 0 , null, true )
       ProcessEvent( "Cycles on Master" , jsonpl.data.quotaMap."bms_bmsStatus.cycles", null, true  )
       ProcessEvent( "Cycles on Slave" ,  jsonpl.data.quotaMap."bms_slave.cycles", null, true  )
       ProcessEvent( "Fault Code mppt" ,  jsonpl.data.quotaMap."mppt.faultCode", null, true  )
       ProcessEvent( "Fault Master Cell" , jsonpl.data.quotaMap."bms_bmsStatus.bmsFault", null, true  )
       ProcessEvent( "Fault Slave Cell" ,  jsonpl.data.quotaMap."bms_slave.bmsFault", null, true  )
       ProcessEvent( "SOC Master Cell" ,  jsonpl.data.quotaMap."bms_bmsStatus.f32ShowSoc", "%", true  )
       ProcessEvent( "SOC Master Display" , jsonpl.data.quotaMap."bms_emsStatus.lcdShowSoc", "%", true )
       ProcessEvent( "SOC Slave Cell" ,  jsonpl.data.quotaMap."bms_slave.soc", "%", true  )
       ProcessEvent( "SOC Slave Display" , jsonpl.data.quotaMap."bms_slave.f32ShowSoc", "%", true )
       ProcessEvent( "Temp DC" ,  jsonpl.data.quotaMap."pd.carTemp"  * mul + adder, tunit, true )
       ProcessEvent( "Temp Inverter Out" , jsonpl.data.quotaMap."inv.outTemp" * mul + adder, tunit, true  )
       ProcessEvent( "Temp Master Cell" , jsonpl.data.quotaMap."bms_bmsStatus.temp" * mul + adder, tunit, true  )
       ProcessEvent( "Temp Mppt" ,  jsonpl.data.quotaMap."mppt.mpptTemp"* mul + adder , tunit, ture  )
       ProcessEvent( "Temp Slave Cell" , jsonpl.data.quotaMap."bms_slave.temp" * mul + adder , tunit, true  )
       ProcessEvent( "Time Remain" ,  jsonpl.data.quotaMap."pd.remainTime", "mins", true )
       ProcessEvent( "Watts DC Out" ,  jsonpl.data.quotaMap."pd.carWatts", "W", true )
       ProcessEvent( "Watts AC In" ,  jsonpl.data.quotaMap."inv.inputWatts", "W", true )
       ProcessEvent( "Watts AC Out" ,  jsonpl.data.quotaMap."inv.outputWatts", "W", true )
       //ProcessEvent( "Watts Master In" ,  jsonpl.data.quotaMap."bms_bmsStatus.inputWatts","W" )
       //ProcessEvent( "Watts Master Out" ,  jsonpl.data.quotaMap."bms_bmsStatus.outputWatts", "W" )
       ProcessEvent( "Watts Slave In" ,  jsonpl.data.quotaMap."bms_slave.inputWatts", "W", true )
       ProcessEvent( "Watts Slave Out" ,  jsonpl.data.quotaMap."bms_slave.outputWatts", "W", true )
       ProcessEvent( "Limit Charging Rate" ,  jsonpl.data.quotaMap."mppt.cfgChgWatts", "%", true )
       ProcessEvent( "Limit Discharge" ,  jsonpl.data.quotaMap."bms_emsStatus.minDsgSoc", "%", true )
       ProcessEvent( "Limit Charge" ,  jsonpl.data.quotaMap."bms_emsStatus.maxChargeSoc", "%", true )
       ProcessEvent( "SmartGen On Point" ,  jsonpl.data.quotaMap."bms_emsStatus.minOpenOilEb", "%", true )
       ProcessEvent( "SmartGen Off Point" ,  jsonpl.data.quotaMap."bms_emsStatus.maxCloseOilEb", "%", true )     
       ProcessEvent( "Limit CarCharge Amps" ,  jsonpl.data.quotaMap."mppt.dcChgCurrent" / 1000, "A", true )
       ProcessEvent( "Output XBoost" ,  jsonpl.data.quotaMap."mppt.cfgAcXboost", null, true )
       ProcessEvent( "TimeOut Unit" ,  jsonpl.data.quotaMap."pd.standbyMin" / 60 , null, true )
       ProcessEvent( "TimeOut Screen" ,  jsonpl.data.quotaMap."pd.lcdOffSec" / 60, null, true ) 
       ProcessEvent( "Timeout AC Output" ,  jsonpl.data.quotaMap."mppt.acStandbyMins" / 60, null, true )
       ProcessEvent( "Timeout DC Output" ,  jsonpl.data.quotaMap."mppt.carStandbyMin" / 60, null, true )
            
    break
    case "river":
       //log.info "Loading River Data Map"
       ACOutput_Enabled = jsonpl.data.quotaMap."inv.cfgAcEnabled"
       DCOutput_Enabled = jsonpl.data.quotaMap."pd.carSwitch"
       USBOutput_Enabled = null
       LEDOutput_Enabled = jsonpl.data.quotaMap."pd.ledState"
       XBoost_Enabled = null
       AcAlways_Enabled = jsonpl.data.quotaMap."inv.acPassByAutoEn"
       sendEvent (name: "battery" , vaule: jsonpl.data.quotaMap."pd.soc", unit: "%" )
       sendEvent (name: "power" , value: jsonpl.data.quotaMap."inv.outputWatts", unit: "W" )
       Integer ttemp = jsonpl.data.quotaMap."inv.outTemp" * mul + adder
       sendEvent(name: "temperature", value: ttemp, unit: tunit, isStateChanged: true )
       ProcessEvent(  "Output Status AC" , jsonpl.data.quotaMap."inv.cfgAcEnabled", null, true)
       ProcessEvent(  "Output Status DC" , jsonpl.data.quotaMap."pd.carSwitch", null, true )
       ProcessEvent(  "Output Status USB" , 0 , null, true)
       ProcessEvent(  "Output Status LED" , jsonpl.data.quotaMap."pd.ledState", null, true)
       ProcessEvent(  "Cycles on Master" , jsonpl.data.quotaMap."bmsMaster.cycles", null, true )
       if (jsonpl.data.quotaMap.jsonpl.data.quotaMap."bmsSlave1.cycles" != null) ProcessEvent(  "Cycles on Slave" , jsonpl.data.quotaMap."bmsSlave1.cycles", null, true)
       ProcessEvent(  "Fault Code mppt" , jsonpl.data.quotaMap."mppt.faultCode", null, true )
       ProcessEvent(  "Fault Master Cell" , jsonpl.data.quotaMap."bmsMaster.bmsFault", null, true )
       ProcessEvent(  "SOC Master Cell" , jsonpl.data.quotaMap."bmsMaster.soc", "%", true )
       if (jsonpl.data.quotaMap."bmsSlave1.soc" != null)ProcessEvent(  "SOC Slave Cell" , jsonpl.data.quotaMap."bmsSlave1.soc", "%", true  )
       ProcessEvent(  "Temp DC" , value: jsonpl.data.quotaMap."pd.carTemp"  * mul + adder,  tunit, true )
       ProcessEvent(  "Temp Inverter Out" , jsonpl.data.quotaMap."inv.outTemp" * mul + adder, tunit, true )
       ProcessEvent(  "Temp Inverter In" , jsonpl.data.quotaMap."inv.inTemp" * mul + adder, tunit, true )
       ProcessEvent(  "Temp Master Cell" , jsonpl.data.quotaMap."bmsMaster.temp" * mul + adder, tunit, true )
       //ProcessEvent(  "Temp Mppt" , jsonpl.data.quotaMap."mppt.mpptTemp"* mul + adder, tunit, true )
       if (jsonpl.data.quotaMap."bmsSlave1.temp" != null)ProcessEvent(  "Temp Slave Cell" , jsonpl.data.quotaMap."bmsSlave1.temp" * mul + adder, tunit, true )
       ProcessEvent(  "Time Remain" , jsonpl.data.quotaMap."pd.remainTime", unit: "mins", true )
       ProcessEvent(  "Battery Status" ,  BatteryStatus, null, true )
       ProcessEvent(  "Watts DC Out" , jsonpl.data.quotaMap."pd.carWatts", unit: "W", true )
       ProcessEvent(  "Watts AC In" , jsonpl.data.quotaMap."inv.inputWatts", unit: "W", true )
       ProcessEvent(  "Watts AC Out" , jsonpl.data.quotaMap."inv.outputWatts", unit: "W", true )
       //ProcessEvent(  "Watts Master In" , jsonpl.data.quotaMap."bmsMaster.inputWatts", "W", true )
       //ProcessEvent(  "Watts Master Out" , jsonpl.data.quotaMap."bmsMaster.outputWatts", "W", true )
       //ProcessEvent(  "Watts Slave In" , jsonpl.data.quotaMap."bmsSlave.inputWatts", "W", true )
       //ProcessEvent(  "Watts Slave Out" , jsonpl.data.quotaMap."bmsSlave.outputWatts", "W", true  )
    break 
    case "deltapro":
       //log.info "Loading Delta Pro Data Map"
       ACOutput_Enabled = jsonpl.data.quotaMap."inv.cfgAcEnabled"
       DCOutput_Enabled = jsonpl.data.quotaMap."mppt.carState"
       USBOutput_Enabled = null
       LEDOutput_Enabled = null
       XBoost_Enabled = jsonpl.data.quotaMap."mppt.cfgAcXboost"
       AcAlways_Enabled = jsonpl.data.quotaMap."inv.acPassByAutoEn"
       sendEvent(name: "battery" , value: jsonpl.data.quotaMap."bmsMaster.soc", unit: "%", isStateChanged: true )
       sendEvent (name: "power" , value: jsonpl.data.quotaMap."inv.outputWatts", unit: "W", isStateChanged: true )
       Integer ttemp = jsonpl.data.quotaMap."bmsMaster.temp" * mul + adder 
       sendEvent(name: "temperature", value: ttemp, unit: tunit, isStateChanged: true ) 
       ProcessEvent(  "Output Status AC" , jsonpl.data.quotaMap."inv.cfgAcEnabled", null, true )
       ProcessEvent(  "Output Status DC" , jsonpl.data.quotaMap."mppt.carState", null, true  )
       ProcessEvent(  "Output Status USB" , 0 , null, true )
       ProcessEvent(  "Output Status LED" , 0 , null, true )
       //ProcessEvent(  "AC Always On" , 
       ProcessEvent(  "Cycles on Master" , jsonpl.data.quotaMap."bmsMaster.cycles", null, true )
       ProcessEvent(  "Cycles on Slave" , jsonpl.data.quotaMap."bmsSlave1.cycles", null, true )
       ProcessEvent(  "Fault Code mppt" , jsonpl.data.quotaMap."mppt.faultCode", null, true )
       ProcessEvent(  "Fault Master Cell" , jsonpl.data.quotaMap."bmsMaster.bmsFault", null, true )
       ProcessEvent(  "Fault Slave Cell" , jsonpl.data.quotaMap."bmsSlave1.bmsFault", null, true )
       ProcessEvent(  "SOC Master Cell" , jsonpl.data.quotaMap."bmsMaster.soc", "%",  true )
       //ProcessEvent(  "SOC Master Display" , jsonpl.data.quotaMap."bmsMaster.fShowSoc", "%",  true )
       ProcessEvent(  "SOC Slave Cell" , jsonpl.data.quotaMap."bmsSlave1.soc", "%",  true )
       //ProcessEvent(  "SOC Slave Display" , jsonpl.data.quotaMap."bmsSlave.fShowSoc",  "%", true )
       ProcessEvent(  "Temp DC" , jsonpl.data.quotaMap."pd.carTemp"  * mul + adder, tunit, true )
       ProcessEvent(  "Temp Inverter" , jsonpl.data.quotaMap."inv.outTemp" * mul + adder, tunit, true )
       ProcessEvent(  "Temp Master Cell" , jsonpl.data.quotaMap."bmsMaster.temp" * mul + adder, tunit, true )
       ProcessEvent(  "Temp Mppt" , jsonpl.data.quotaMap."mppt.mpptTemp" * mul + adder, tunit, true )
       if (jsonpl.data.quotaMap."bmsSlave1.temp" != null) ProcessEvent(  "Temp Slave Cell" , jsonpl.data.quotaMap."bmsSlave1.temp" * mul + adder, tunit, true )
       ProcessEvent( "Time Remain" ,  jsonpl.data.quotaMap."pd.remainTime", "mins", true )
       ProcessEvent(  "Watts DC Out" , jsonpl.data.quotaMap."pd.carWatts", "W", true )
       ProcessEvent(  "Watts AC In" , jsonpl.data.quotaMap."inv.inputWatts", "W", true )
       ProcessEvent(  "Watts AC Out" , jsonpl.data.quotaMap."inv.outputWatts", "W", true )
       //ProcessEvent(  "Watts Master In" , jsonpl.data.quotaMap."bmsMaster.inputWatts", "W", true )
       //ProcessEvent(  "Watts Master Out" , jsonpl.data.quotaMap."bmsMaster.outputWatts", "W", true )
       if (jsonpl.data.quotaMap."bmsSlave1.inputWatts" != null ) ProcessEvent(  "Watts Slave In" , jsonpl.data.quotaMap."bmsSlave1.inputWatts", "W", true )
       if (jsonpl.data.quotaMap."bmsSlave1.outputWatts" != null ) ProcessEvent(  "Watts Slave Out" , jsonpl.data.quotaMap."bmsSlave1.outputWatts", "W", true )
       ProcessEvent( "Limit Charging Rate" ,  jsonpl.data.quotaMap."inv.cfgSlowChgWatts", "%", true )
       ProcessEvent( "Limit Discharge" ,  jsonpl.data.quotaMap."bms_emsStatus.minDsgSoc", "%", true )
       ProcessEvent( "Limit Charge" ,  jsonpl.data.quotaMap."bms_emsStatus.maxChargeSoc", "%", true )
       ProcessEvent( "SmartGen On Point" ,  jsonpl.data.quotaMap."bms_emsStatus.minOpenOilEb", "%", true )
       ProcessEvent( "SmartGen Off Point" ,  jsonpl.data.quotaMap."bms_emsStatus.maxCloseOilEb", "%", true )     
       ProcessEvent( "Limit CarCharge Amps" ,  jsonpl.data.quotaMap."mppt.cfgDcChgCurrent" / 1000, "A", true )
       ProcessEvent( "Output XBoost" ,  jsonpl.data.quotaMap."mppt.cfgAcXboost", null, true )
       ProcessEvent( "TimeOut Unit" ,  jsonpl.data.quotaMap."pd.standByMode" / 60 , null, true )
       ProcessEvent( "TimeOut Screen" ,  jsonpl.data.quotaMap."pd.lcdOffSec" / 60, null, true ) 
       ProcessEvent( "Timeout AC Output" ,  jsonpl.data.quotaMap."inv.cfgStandbyMin" / 60, null, true )
       //ProcessEvent( "Timeout DC Output" ,  jsonpl.data.quotaMap."mppt.carStandbyMin" / 60, null, true )
       ProcessEvent( "DC Charging Watts" ,  jsonpl.data.quotaMap."mppt.inWatts",  null, true )
       
       break
    default:
       DCOutput_Enabled = null
       USBOutput_Enabled = null
       LEDOutput_Enabled = null
       XBoost_Enabled = null
       log.info "model type not found - model input currently set as " + EFmodel
   }
   sendEvent(name: "Last Update", value: date, isStateChanged: true)
   //check if output states have changed and update the child's state if required.
   if (ACOutput_Enabled != state.ACoutput) {
      state.cdtype = 1
      def cd = fetchChild("Switch")
      if (ACOutput_Enabled == 1) {
         cd.parse([[name: "switch", value: "on", descriptionText: "AC Switch was turned on"]])
         state.ACoutput = 1
      } else {
         cd.parse([[name: "switch", value: "off", descriptionText: "AC Switch was turned off"]])
         state.ACoutput = 0
      }
  }
  if (DCOutput_Enabled != state.DCoutput) {
     state.cdtype = 2
     def cd = fetchChild("Switch")
     if (DCOutput_Enabled == 1) {
        log.info "updating switch state ON"
        cd.parse([[name: "switch", value: "on", descriptionText: "DC Switch was turned on"]])
        state.DCoutput = 1
     } else {
        log.info "updating switch state OFF"
        cd.parse([[name: "switch", value: "off", descriptionText: "DC Switch was turned off"]])
        state.DCoutput = 0
     }
  }
  if (USBOutput_Enabled != NULL) {
     if (USBOutput_Enabled != state.USBoutput) {
        state.cdtype = 3
        def cd = fetchChild("Switch")
        if (USBOutput_Enabled == 1) {
           cd.parse([[name: "switch", value: "on", descriptionText: "USB Switch was turned on"]])
           state.USBoutput = 1
        } else {
           cd.parse([[name: "switch", value: "off", descriptionText: "USB Switch was turned off"]])
           state.USBoutput = 0
        }
     }
  }
  if (LEDOutput_Enabled != NULL) {
    if (LEDOutput_Enabled != state.LEDoutput) {
       state.cdtype = 4
       def cd = fetchChild("Switch")
       if (LEDOutput_Enabled == 0) {
          cd.parse([[name: "switch", value: "off", descriptionText: "LED light was turned off"]])
          state.LEDoutput = 0
       } else {
          cd.parse([[name: "switch", value: "on", descriptionText: "LED Light was turned on"]])
          state.LEDoutput = LEDOutput_Enabled
       }
     }
  }
  if (XBoost_Enabled != NULL) {
    if (XBoost_Enabled != state.XBoost) {
       state.cdtype = 5
       def cd = fetchChild("Switch")
       if (XBoost_Enabled == 0) {
          cd.parse([[name: "switch", value: "off", descriptionText: "XBoost was turned off"]])
          state.XBoost = 0
       } else {
          cd.parse([[name: "switch", value: "on", descriptionText: "XBoost was turned on"]])
          state.XBoost = 1
       }
    }
  }   
  if (AcAlways_Enabled != NULL) {
    if (AcAlways_Enabled != state.AcAlways) {
       state.cdtype = 6
       def cd = fetchChild("Switch")
       if (AcAlways_Enabled == 0) {
          cd.parse([[name: "switch", value: "off", descriptionText: "AcAlways was turned off"]])
          state.AcAlways = 0
       } else {
          cd.parse([[name: "switch", value: "on", descriptionText: "AcAlways was turned on"]])
          state.AcAlways = 1
       }
    }
  }     
  state.reloadData = 1
  UpdateTile()
}

//refresh data by sending mqtt command requesting data update
def refreshdata() {
  if (state.refreshpayload == null) {
    log.info "model type not found - model input currently set as " + EFmodel
  }
  if (state.SetUpdateTime > 120 ) {
    state.reload = 1
  }else{ 
    state.reload = state.reload + 1
    if (state.reload > settings.allrefresh ) state.reload =  1  
  }   
  ptopic = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/get"
  interfaces.mqtt.publish(ptopic, state.refreshpayload)
}

def publishMsg(String s) {
  //   Not a working feature
  if (logEnable) log.debug "Sent this: ${s} to ${settings?.topicPub} - QOS Value: ${settings?.QOS.toInteger()} - Retained: ${settings?.retained}"
  interfaces.mqtt.publish(settings?.topicPub, s, settings?.QOS.toInteger(), settings?.retained)
}

def updated() {
  log.info "update running"
  if (logEnable) log.info "Updated..."
  initialize()
}

def Disconnect() {
  log.info "Disconnecting from mqtt"
  interfaces.mqtt.disconnect()
  sendEvent(name: "mqtt Status", value: "OFFLINE", isStateChanged: true)
  log.info "MQTT disconnected"

}
def initialize() {
  if (logEnable) log.info "initialize"
  if (logEnable) runIn(900, logsOff)
  device.updateSetting("Deltaflag", [value: "false", type: "bool"])
  switch (EFmodel) {
  case "delta2":
    state.AConPayload = /{"from":"Android","id":"498321003","moduleType":5,"operateType":"acOutCfg","params":{"out_voltage":-1,"out_freq":255,"xboost":255,"enabled":1},"version":"1.0"}/
    state.ACoffPayload = /{"from":"Android","id":"498321003","moduleType":5,"operateType":"acOutCfg","params":{"out_voltage":-1,"out_freq":255,"xboost":255,"enabled":0},"version":"1.0"}/
    state.DConPayload = /{"from":"Android","id":"498321003","moduleType":5,"operateType":"mpptCar","params":{"enabled":1},"version":"1.0"}/
    state.DCoffPayload = /{"from":"Android","id":"498321003","moduleType":5,"operateType":"mpptCar","params":{"enabled":0},"version":"1.0"}/
    state.USBonPayload = /{"from":"Android","id":"498321003","moduleType":1,"operateType":"dcOutCfg","params":{"enabled":1},"version":"1.0"}/
    state.USBoffPayload = /{"from":"Android","id":"498321003","moduleType":1,"operateType":"dcOutCfg","params":{"enabled":0},"version":"1.0"}/
    state.LEDonPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 00,"state": 1},"version": "1.0"}/
    state.LEDoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 00,"state": 0},"version": "1.0"}/
    state.refreshpayload = /{"from":"Android","id":"380541001","moduleType":0,"operateType":"latestQuotas","params":{},"version":"1.0"}/
    state.XboostONPayload = /{"from":"Android","id":"153151096","moduleType":5,"operateType":"acOutCfg","params":{"out_voltage":-1,"out_freq":255,"xboost":1,"enabled":255},"version":"1.0"}/
    state.XboostOFFPayload = /{"from":"Android","id":"157161098","moduleType":5,"operateType":"acOutCfg","params":{"out_voltage":-1,"out_freq":255,"xboost":0,"enabled":255},"version":"1.0"}/
    state.AcAlwaysOFFPayload = /{"from": "Android","id": "435361475","moduleType": 0,"operateType": "TCP","params": {"id": 84,"enabled": 0},"version": "1.0"} /
    state.AcAlwaysONPayload =  /{"from": "Android","id": "435361475","moduleType": 0,"operateType": "TCP","params": {"id": 84,"enabled": 1},"version": "1.0"} / 
    break
  case "river":
    state.AConPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 66,"enabled": 1},"version":"1.0"}/
    state.ACoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 66,"enabled": 0},"version":"1.0"}/
    state.DConPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 34,"enabled": 1},"version": "1.0"}/
    state.DCoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 34,"enabled": 0},"version": "1.0"}/
    state.USBonPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 72,"enabled": 1},"version": "1.0"}/
    state.USBoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 72,"enabled": 0},"version": "1.0"}/
    state.LEDonPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 35,"state": 1},"version": "1.0"}/
    state.LEDoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 35,"state": 0},"version": "1.0"}/
    state.refreshpayload = /{"from":"Android","id":"380541001","moduleType":0,"operateType":"latestQuotas","params":{},"version":"1.0"}/
    state.AcAlwaysOFFPayload = /{"from": "Android","id": "435361475","moduleType": 0,"operateType": "TCP","params": {"id": 84,"enabled": 0},"version": "1.0"} /
    state.AcAlwaysONPayload =  /{"from": "Android","id": "435361475","moduleType": 0,"operateType": "TCP","params": {"id": 84,"enabled": 1},"version": "1.0"} / 
      
    break
  case "deltapro":
    state.AConPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 66,"enabled": 1},"version":"1.0"}/
    state.ACoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 66,"enabled": 0},"version":"1.0"}/
    state.DConPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 81,"enabled": 1},"version": "1.0"}/
    state.DCoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 81,"enabled": 0},"version": "1.0"}/
    state.USBonPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 72,"enabled": 1},"version": "1.0"}/
    state.USBoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 72,"enabled": 0},"version": "1.0"}/
    state.LEDonPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 00,"state": 1},"version": "1.0"}/
    state.LEDoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 00,"state": 0},"version": "1.0"}/
    state.refreshpayload = /{"from":"Android","id":"380541001","moduleType":0,"operateType":"latestQuotas","params":{},"version":"1.0"}/
    state.XboostONPayload = /{"from": "Android","id": "476501541","moduleType": 0,"operateType": "TCP","params": {"xboost": 1,"id": 66},"version": "1.0"} /
    state.XboostOFFPayload = /{"from": "Android","id": "476501541","moduleType": 0,"operateType": "TCP","params": {"xboost": 0,"id": 66},"version": "1.0"} /
    state.AcAlwaysOFFPayload = /{"from": "Android","id": "435361475","moduleType": 0,"operateType": "TCP","params": {"id": 84,"enabled": 0},"version": "1.0"} /
    state.AcAlwaysONPayload =  /{"from": "Android","id": "435361475","moduleType": 0,"operateType": "TCP","params": {"id": 84,"enabled": 1},"version": "1.0"} /  
    break
  default:
    state.AConPayload = null
    state.ACoffPayload = null
    state.DConPayload = null
    state.DCoffPayload = null
    state.USBonPayload = null
    state.USBoffPayload = null
    state.LEDonPayload = null
    state.LEDoffPayload = null
    state.refreshpayload = null
    log.info "model type not found - model input currently set as " + EFmodel
  }
  if (settings.updateTime < 15) {
    state.SetUpdateTime = 15
  } else {
    state.SetUpdateTime = settings.updateTime
  }
  state.reloadData = 0
  state.reload = settings.allrefresh
  state.tbs = "00:00"
  state.firstrun = 0
  log.info "reset initialize flag=" + state.reloadData
  mqttConnect()
  refreshdata()
}

//set up mqtt server connection
def mqttConnect() {
  try {
    if (settings?.retained == null) settings?.retained = false
    if (settings?.QOS == null) setting?.QOS = "0"
    //open connection
    mqttbroker = "ssl://" + settings?.MQTTBroker + ":8883"
    settings?.topicSub = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/get_reply"
    if (logEnable) log.info "broker " + mqttbroker
    if (logEnable) log.info "client " + mqttclientname
    if (logEnable) log.info "username   " + username
    if (logEnable) log.info "password " + password
    interfaces.mqtt.connect(mqttbroker,
      mqttclientname,
      username,
      password,
      lastWillQos: 0,
      lastWillMessage: "offline",
      lastWillRetain: true,
      tlsVersion: 1.2)

    if (logEnable) log.info "mqtt.con" + mqttConnect
       //give it a chance to start
       pauseExecution(1000)
       //log.info "Connection established"
       if (logEnable) log.debug "Subscribed to: ${settings?.topicSub}"
          log.info settings?.topicSub
          interfaces.mqtt.subscribe(settings?.topicSub)
          sendEvent(name: "mqtt Status", value: "Online", isStateChanged: true)
       } catch (e) {
       sendEvent(name: "mqtt Status", value: "OFFLINE", isStateChanged: true)  
       if (logEnable) log.debug "Initialize error: ${e.message}"
    }
}

def mqttClientStatus(String status) {
  log.info "mqttClientStatus"
  if (!status.contains("succeeded")) {
    try {
      interfaces.mqtt.disconnect()
    } catch (e) {}
    sendEvent(name: "mqtt Status", value: "OFFLINE", isStateChanged: true)
    if (logEnable) log.debug "Broker: ${status} Will restart in 15 seconds"
    runIn(15, mqttConnect)
  }
}

def logsOff() {
  log.warn "Debug logging disabled."
  device.updateSetting("logEnable", [value: "false", type: "bool"])
}

void componentRefresh(cd) {
log.info "received refresh request from ${cd.displayName}"
refreshdata()
}

//when switch state changes are requested - update the child and send MQTT commmand to change device - 
// wait for 5 seconds and then request mqtt data refresh
void ACSwitchON() {
  state.cdtype = 1
  def cd = fetchChild("Switch")
  //log.info "ACSwitchON cd on=" + cd
  cd.parse([[name: "switch", value: "on", descriptionText: "AC Switch was turned on"]])
  log.info "AC switch on request"
  tempPayload = state.AConPayload
  RunRequest (tempPayload)
}

void ACSwitchOFF() {
  state.cdtype = 1
  def cd = fetchChild("Switch")
  log.info "ACSwitchOFF cd off=" + cd
  cd.parse([[name: "switch", value: "off", descriptionText: "AC Switch was turned off"]])
  tempPayload = state.ACoffPayload
  RunRequest (tempPayload)
}

void DCSwitchON() {
  state.cdtype = 2
  def cd = fetchChild("Switch")
  cd.parse([[name: "switch", value: "on", descriptionText: "DC Switch was turned on"]])
  log.info "DC switch on request"
  tempPayload = state.DConPayload
  RunRequest (tempPayload)
 }

void DCSwitchOFF() {
  state.cdtype = 2
  def cd = fetchChild("Switch")
  log.info "DCSwitchOFF cd off=" + cd
  cd.parse([[name: "switch", value: "off", descriptionText: "DC Switch was turned off"]])
  log.info "DC switch off request"
  tempPayload = state.DCoffPayload
  RunRequest (tempPayload)
 }

void USBSwitchON() {
  if (EFmodel == "delta2") {
    state.cdtype = 3
    def cd = fetchChild("Switch")
    log.info "USBSwitchON cd on=" + cd
    cd.parse([[name: "switch", value: "on", descriptionText: "USB Switch was turned on"]])
    log.info "USB switch on request"
    tempPayload = state.USBonPayload
    RunRequest (tempPayload)
    } else {
    log.info "USB Switch not supported due to model selection"
  }
}
void USBSwitchOFF() {
  if (EFmodel == "delta2") {
    state.cdtype = 3
    def cd = fetchChild("Switch")
    log.info "USBSwitchOFF cd off=" + cd
    cd.parse([[name: "switch", value: "off", descriptionText: "USB Switch was turned off"]])
    log.info "USB switch off request"
    tempPayload = state.USBoffPayload
    RunRequest (tempPayload)
  } else {
    log.info "USB Switch not supported due to model selection"
  }
}

void LEDSwitchON() {
  if (EFmodel == "river") {
    state.cdtype = 4
    def cd = fetchChild("Switch")
    log.info "LEDSwitchOFF cd on=" + cd
    cd.parse([[name: "switch", value: "on", descriptionText: "LED Light was turned on"]])
    log.info "LED light on request"
    tempPayload = state.LEDonPayload
    RunRequest (tempPayload)
  } else {
    log.info "LED Switch not supported due to model selection"
  }
}
void LEDSwitchOFF() {
  if (EFmodel == "river") {
    state.cdtype = 4
    def cd = fetchChild("Switch")
    log.info "LEDSwitchOFF cd off=" + cd
    cd.parse([[name: "switch", value: "off", descriptionText: "LED Light was turned off"]])
    log.info "LED light off request"
    tempPayload = state.LEDoffPayload
    RunRequest (tempPayload)
  } else {
    log.info "LED Switch not supported due to model selection"
  }
}
void XBoostON() {
  if (EFmodel == "deltapro" || "delta2 ") {
    state.cdtype = 5
    def cd = fetchChild("Switch")
    log.info "XboostON cd on=" + cd
    cd.parse([[name: "switch", value: "on", descriptionText: "XboostON was turned on"]])
    log.info "XboostON on request"
    tempPayload = state.XboostONPayload
    RunRequest (tempPayload)
  } else {
    log.info "Xboost not supported due to model selection"
  }
}
void XBoostOFF() {
  if (EFmodel == "deltapro"  || "delta2" )   {
    state.cdtype = 5
    def cd = fetchChild("Switch")
    log.info "XboostOFF cd off=" + cd
    cd.parse([[name: "switch", value: "off", descriptionText: "XboostOFF was turned off"]])
    log.info "XboostOFF off request"
    tempPayload = state.XboostOFFPayload
    RunRequest (tempPayload)
  } else {
    log.info "Xboost not supported due to model selection"
  }
}
void PowerUpAcON() {
  if (EFmodel == "deltapro" || "delta2 ") {
    state.cdtype = 6
    def cd = fetchChild("Switch")
    log.info "AcAlways cd on=" + cd
    cd.parse([[name: "switch", value: "on", descriptionText: "PowerUpAc was turned on"]])
    log.info "PowerUpAc on request"
    tempPayload = state.AcAlwaysONPayload
    RunRequest (tempPayload)
  } else {
    log.info "ACAlways not supported due to model selection"
  }
}
void PowerUpAcOFF() {
  if (EFmodel == "deltapro"  || "delta2" )   {
    state.cdtype = 6
    def cd = fetchChild("Switch")
    log.info "PowerUpAc cd off=" + cd
    cd.parse([[name: "switch", value: "off", descriptionText: "PowerUpAc was turned off"]])
    log.info "PowerUpAc off request"
    tempPayload = state.AcAlwaysOFFPayload
    RunRequest (tempPayload)
  } else {
    log.info "ACAlways not supported due to model selection"
  }
}

//get data for switches 1, 2, and 3. If child1 does not exist - create all of them.
def fetchChild(String type) {
  String thisId = device.id
  log.info "fetchChild run >> thisID=" + thisId + " cdtype=" + state.cdtype
  def cd = getChildDevice("${thisId}${state.cdtype}-Switch")
  log.info "fetchchild CD=" + cd
  if (cd == null) {
    if (state.cdtype == 1) cd1 = addChildDevice("hubitat", "Generic Component Switch", "${thisId}1-Switch", [name: "EF AC Switch", isComponent: true])
    if (state.cdtype == 2) cd2 = addChildDevice("hubitat", "Generic Component Switch", "${thisId}2-Switch", [name: "EF DC Switch", isComponent: true])
    if (EFmodel == "delta2") {
      if (state.cdtype == 3 )   cd3 = addChildDevice("hubitat", "Generic Component Switch", "${thisId}3-Switch", [name: "EF USB Switch", isComponent: true])
      if (state.cdtype == 5 )   cd5 = addChildDevice("hubitat", "Generic Component Switch", "${thisId}5-Switch", [name: "EF XBoost", isComponent: true])
      if (state.cdtype == 6 )   cd6 = addChildDevice("hubitat", "Generic Component Switch", "${thisId}6-Switch", [name: "EF AcAlways", isComponent: true])
    }
    if (EFmodel == "river") {
      if (state.cdtype == 4 )  cd4 = addChildDevice("hubitat", "Generic Component Switch", "${thisId}4-Switch", [name: "EF LED Switch", isComponent: true])
    }
    if (EFmodel == "deltapro") {
      if (state.cdtype == 5 )  cd5 = addChildDevice("hubitat", "Generic Component Switch", "${thisId}5-Switch", [name: "EF XBoost", isComponent: true]) 
      if (state.cdtype == 6 )  cd6 = addChildDevice("hubitat", "Generic Component Switch", "${thisId}6-Switch", [name: "EF AcAlways", isComponent: true])
    }   
   log.info "type=" + type + " thisid=" + thisId + "displayname=" + device.displayName
   
      List < Map > defaultValues = []
    cd.parse(defaultValues)
  }
  return cd
}

// child has requested state change to ON - determine what child is asking for change and run sequence to update device
void componentOn(cd) {
  getChildDevice(cd.deviceNetworkId).parse([
    [name: "switch", value: "on", descriptionText: "${cd.displayName} was turned on"]])
  switch (cd.displayName) {
  case "EF AC Switch":
    ACSwitchON()
    break
  case "EF USB Switch":
    USBSwitchON()
    break
  case "EF DC Switch":
    DCSwitchON()
    break
  case "EF LED Switch":
    LEDSwitchON()
    break
  case "EF XBoost":
    XBoostON() 
    break
  case "EF AcAlways":
    PowerUpAcON()   
    break 
   }
}

// child has requested state change to OFF - determine what child is asking for change and run sequence to update device
void componentOff(cd) {
  getChildDevice(cd.deviceNetworkId).parse([
    [name: "switch", value: "off", descriptionText: "${cd.displayName} was turned off"]])
  switch (cd.displayName) {
  case "EF AC Switch":
    ACSwitchOFF()
    break
  case "EF USB Switch":
    USBSwitchOFF()
    break
  case "EF DC Switch":
    DCSwitchOFF()
    break
  case "EF LED Switch":
    LEDSwitchOFF()
    break
    case "EF XBoost":
    XBoostOFF() 
    break 
  case "EF AcAlways":
    PowerUpAcOFF()   
    break 
   }
}
// Process data to check against current state value and then send an event if it has changed
// After 5 updates - update all attrubites to catch any misses - refresh count in refreshdata() block
def ProcessEvent(Variable, Value, Unit = null, ForceEvent = false) {
    Integer Vtemp = Value
    if ((state."${ Variable }" != Vtemp) || (state.reload == 1 )) {
       state."${ Variable }" = Vtemp
      if (Unit != null) {
        sendEvent(name: "${ Variable }", value: Vtemp, unit: Unit, isStateChanged: true)
      } else {
        sendEvent(name: "${ Variable }", value: Vtemp, isStateChanged: true)
      }
   }
}

private void UpdateTile() {
  def val = ""
  // Create special compound/html tile
  val = "DC Temps:" + device.currentValue("Temp DC") + " Mppt Temp:" + device.currentValue("Temp Mppt") + " Master Temp:" + device.currentValue("Temp Master Cell") + " Slave Temp:" + device.currentValue("Temp Slave Cell").toString()
  val1 = "<B>DC Temp:</B>" + device.currentValue("Temp DC") + " <B>Mppt Temp:</B>" + device.currentValue("Temp Mppt") + " <B>Master Temp:</B>" + device.currentValue("Temp Master Cell") + " <B>Slave Temp:</B>" + device.currentValue("Temp Slave Cell").toString()
     if( device.currentValue( "htmlTile1" ).toString() != val1 ){
     //   sendEvent( name: "htmlTile1", value: val1 )
     }
}
def LimitWattsCharging(cdata) {
    if (EFmodel == "deltapro") {
     if (cdata > 1800) cdata = 1800
  }else{
     if (cdata > 1500) cdata = 1500
  }   
  if (cdata <200 ) cdata= 200
  log.info "LimitWattsCharging request = " + cdata  
  if (EFmodel == "delta2") tempPayload =  / {"from":"Android","id":"408451032","moduleType":5,"operateType":"acChgCfg","params":{"chgWatts":${cdata},"chgPauseFlag":255},"version":"1.0"}/
  if (EFmodel == "deltapro") tempPayload =  /{"from":"Android","id":"173871057","moduleType":0,"operateType":"TCP","params":{"slowChgPower":${cdata},"id":69},"version":"1.0"}/
  if (EFmodel == "River") tempPayload =   /{"from":"Android","id":"173871057","moduleType":0,"operateType":"TCP","params":{"slowChgPower":${cdata},"id":69},"version":"1.0"}/  
  RunRequest (tempPayload)
  }

def LimitDischarge(cdata) {
  if (cdata > 30) cdata= 30
  if (cdata < 0 ) cdata = 0
  if (EFmodel == "delta2") tempPayload =  / {"from":"Android","id":"432011035","moduleType":2,"operateType":"dsgCfg","params":{"minDsgSoc":${cdata}},"version":"1.0"}/
  if (EFmodel == "deltapro") tempPayload =/ {"from":"Android","id":"175921141","moduleType":0,"operateType":"TCP","params":{"id":51,"minDsgSoc":${cdata}},"version":"1.0"}/
  if (EFmodel == "River") tempPayload =   / {"from":"Android","id":"175921141","moduleType":0,"operateType":"TCP","params":{"id":51,"minDsgSoc":${cdata}},"version":"1.0"}/  
  RunRequest (tempPayload)
  }

def LimitCharge(cdata) {
  if (cdata < 50) cdata= 50 
  if (cdata > 100) cdata = 100
  if (EFmodel == "delta2") tempPayload =   / {"from":"Android","id":"236231052","moduleType":2,"operateType":"upsConfig","params":{"maxChgSoc":${cdata}},"version":"1.0"}/
  if (EFmodel == "deltapro") tempPayload = / {"from": "Android","id": "288791335","moduleType": 0,"operateType": "TCP","params": {"maxChgSoc": ${cdata},"id": 49},"version": "1.0"}/
  if (EFmodel == "River") tempPayload =    / {"from": "Android","id": "288791335","moduleType": 0,"operateType": "TCP","params": {"maxChgSoc": ${cdata},"id": 49},"version": "1.0"}/  
  RunRequest (tempPayload)
  }

def SmartGenAutoOFF(cdata) {
  if (cdata < 50) cdata= 50
  if (cdata >100 ) cdata = 100
  if (EFmodel == "delta2") tempPayload =  / {"from":"Android","id":"323091083","moduleType":2,"operateType":"closeOilSoc","params":{"closeOilSoc":${cdata}},"version":"1.0"}/
  if (EFmodel == "deltapro") tempPayload =/ {"from":"Android","id":"179771277","moduleType":0,"operateType":"TCP","params":{"closeOilSoc":${cdata},"id":53},"version":"1.0"}/
  if (EFmodel == "River") tempPayload =   / {"from":"Android","id":"179771277","moduleType":0,"operateType":"TCP","params":{"closeOilSoc":${cdata},"id":53},"version":"1.0"}/  
  RunRequest (tempPayload)
  }

def SmartGenAutoON(cdata) {
  if (cdata < 0) cdata= 0 
  if (cdata > 30) cdata = 30
  if (EFmodel == "delta2") tempPayload =  / {"from":"Android","id":"115261063","moduleType":2,"operateType":"openOilSoc","params":{"openOilSoc":${cdata}},"version":"1.0"}/
  if (EFmodel == "deltapro") tempPayload =/ {"from":"Android","id":"462251241","moduleType":0,"operateType":"TCP","params":{"openOilSoc":${cdata},"id":52},"version":"1.0"}/
  if (EFmodel == "River") tempPayload =   / {"from":"Android","id":"462251241","moduleType":0,"operateType":"TCP","params":{"openOilSoc":${cdata},"id":52},"version":"1.0"}/  
  RunRequest (tempPayload)
  }

def LimitCarInput(cdata) {
  if (cdata < 4) cdata = 4 
  if (cdata > 8) cdata = 8
  cdata = cdata * 1000
  if (EFmodel == "delta2") tempPayload =   / {"from":"Android","id":"163361090","moduleType":5,"operateType":"dcChgCfg","params":{"dcChgCfg":${cdata}},"version":"1.0"}/
  if (EFmodel == "deltapro") tempPayload = / {"from":"Android","id":"173801343","moduleType":0,"operateType":"TCP","params":{"currMa":${cdata},"id":71},"version":"1.0"}/
  if (EFmodel == "River") tempPayload =    / {"from":"Android","id":"173801343","moduleType":0,"operateType":"TCP","params":{"currMa":${cdata},"id":71},"version":"1.0"}/  
  RunRequest (tempPayload)
  }

def TimeOutUnit(cdata) {
  if (cdata < 0) cdata = 0 
  if (cdata > 24) cdata = 24
  cdata = cdata * 60
  if (EFmodel == "delta2") tempPayload =  / {"from":"Android","id":"436891007","moduleType":1,"operateType":"standbyTime","params":{"standbyMin":${cdata}},"version":"1.0"}/
  if (EFmodel == "deltapro") tempPayload =  / {"from":"Android","id":"408451032","moduleType":5,"operateType":"acChgCfg","params":{"chgWatts":${cdata},"chgPauseFlag":255},"version":"1.0"}/
  if (EFmodel == "River") tempPayload =  / {"from":"Android","id":"408451032","moduleType":5,"operateType":"acChgCfg","params":{"chgWatts":${cdata},"chgPauseFlag":255},"version":"1.0"}/  
  RunRequest (tempPayload)
  }

def TimeOutScreen(cdata) {
  if (cdata < 0) cdata = 0 
  if (cdata > 30) cdata = 30
  cdata = cdata * 60
  if (EFmodel == "delta2") tempPayload =  / {"from":"Android","id":"409551012","moduleType":1,"operateType":"lcdCfg","params":{"brighLevel":255,"delayOff":${cdata}},"version":"1.0"}/
  if (EFmodel == "deltapro") tempPayload =/ {"from":"Android","id":"332691391","moduleType":0,"operateType":"TCP","params":{"lcdTime":${cdata},"id":39},"version":"1.0"}/
  if (EFmodel == "River") tempPayload =   / {"from":"Android","id":"332691391","moduleType":0,"operateType":"TCP","params":{"lcdTime":${cdata},"id":39},"version":"1.0"}/  
  RunRequest (tempPayload)
  }

def TimeoutACOutput(cdata) {
  if (cdata < 0) cdata = 0 
  if (cdata > 24) cdata = 24
  cdata = cdata * 60
  if (EFmodel == "delta2") tempPayload =  / {"from":"Android","id":"483091022","moduleType":5,"operateType":"standbyTime","params":{"standbyMins":${cdata}},"version":"1.0"}/
  if (EFmodel == "deltapro") tempPayload =  / {"from":"Android","id":"194911444","moduleType":0,"operateType":"TCP","params":{"standByMins":${cdata},"id":153},"version":"1.0"}/
  if (EFmodel == "River") tempPayload =  / {"from":"Android","id":"194911444","moduleType":0,"operateType":"TCP","params":{"standByMins":${cdata},"id":153},"version":"1.0"}/  
  RunRequest (tempPayload)
  }

def TimeoutDCOutput(cdata) {
  if (cdata < 0) cdata = 0 
  if (cdata > 24) cdata = 24
  cdata = cdata * 60
  if (EFmodel == "delta2") tempPayload =  / {"from":"Android","id":"134031004","moduleType":5,"operateType":"carStandby","params":{"standbyMins":${cdata}},"version":"1.0"}/
  if (EFmodel == "deltapro") tempPayload =/ {"from":"Android","id":"194911444","moduleType":0,"operateType":"TCP","params":{"standByMins":0,"id":0},"version":"1.0"}/
  if (EFmodel == "River") tempPayload =   / {"from":"Android","id":"194911444","moduleType":0,"operateType":"TCP","params":{"standByMins":0,"id":0},"version":"1.0"}/  
  RunRequest (tempPayload)
  }

def RunRequest (tempPayload )  {
  ptopic = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/set"
  //log.info "topic=" + ptopic + " payload=" + tempPayload
  interfaces.mqtt.publish(ptopic, tempPayload)
  pauseExecution(5000)
  refreshdata()  
  }




