/**
 *  ****************  ECOFLOW DELTA PRO / DELTA 2 & RIVER SERIES MQTT HUBITAT DRIVER -   ****************
 *                    
 *               
 *                          
 *  D. Dimond 01/24/2023
 *  Hubitat @daryl678
 * 
 *   Design Usage:
 *  This driver is designed to control Ecowflow battery models Delta 2, Delta pro, and River.  
 *  The driver will create child switches based on the model. The Delta2: AC, DC, & USB. The Delta Pro: AC & DC. The River AC, DC, and LED light
 *    
 *       
 *   There is a lot of battery data - The Driver loads a small collection to current device states - There are built-in tools for tracking additional data points. 
 *    1. All device states are loaded on each refresh. 2. A deltflag can be set to on that will display changes in device states to the log file. 
 *   This will help track down additional attributes that can be manually added to the attribute def and ProcessEvent code lines. 
 *
 *   *** Special Instructions *** 
 *   Instructions are required to obtain your MQTT access keys. See Doc for instructions in GitHub folder to get your passcodes.
 *   Or follow this link to grab the instructions:
 *   https://github.com/darryl678/darryl678/blob/Hubitat-EF-Delta-Driver/Accessing-EF-.docx 
 *   
 *   
 *   This driver does not support the deletion of child devices. If changing the battery model after initialization clear child devices out manually 
 *   by loading your device with the internal Hubitat driver called DEVICE and clear out child devices.
 *   
 *  
 *   Thank You(s)
 *    Mark H. for helping me obtain my MQTT codes and getting my copy of MQTT Explorer up and running.
 *    @shircliffs for giving me control of his Delta Pro to test functions and grab variables
 *    @steve101 for providing Delta Pro model parameters
 *    @ronv42 for providing River Parameters
 *    @snell for always taking the time to give detailed responses to all my coding questions
 * 
 * ------------------------------------------------------------------------------------------------------------------------------
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.

 *
 *
 *  Changes:
 *  0.0.0 Needs River MAP and function test.
 *  0.0.0a Added LED Null for DElta2 data map
 *  0.0.0b removed duplicated attribute "Output Status USB", "number"
 *  0.0.0c  ProcessEvent( "Temp Slave Cell" >>tunit was tunitm
 *           ProcessEvent( "Watts DC Out" was  "Watts Car Out"
 *           fixed some code indent cosmetics
 *           set mqtt.ecoflow.com as default broker input
 *           add battery status - remain time and charge time string
 */

import groovy.json.JsonSlurper;

metadata {
  definition(name: "EcoFlow Battery mqtt", namespace: "EFmqtt2", author: "Darryl Dimond", importURL: "not listed") {
    capability "Initialize"
    capability "Actuator"
    capability "Battery"
    capability "PowerMeter"
    capability "TemperatureMeasurement"
    command "ACSwitchON"
    command "ACSwitchOFF"
    command "DCSwitchON"
    command "DCSwitchOFF"
    command "USBSwitchON"
    command "USBSwitchOFF"
    command "LEDSwitchON"
    command "LEDSwitchOFF"
    command "refreshdata"
    
    attribute "Cycles on Master", "number"
    attribute "Cycles on Slave", "number"
    attribute "Output Status AC", "number"
    attribute "Output Status DC", "number"
    attribute "Output Status USB", "number"
    attribute "Output Status LED", "number"
    attribute "Fault Code mppt", "number"
    attribute "Fault Master Cell", "number"
    attribute "Fault Slave Cell", "number"
    attribute "SOC Master Cell", "number"
    attribute "SOC Master Display", "number"
    attribute "SOC Slave Cell", "number"
    attribute "SOC Slave Display", "number"
    attribute "Temp DC", "number"
    attribute "Temp Mppt", "number"
    attribute "Temp Master Cell", "number"
    attribute "Temp Slave Cell", "number"
    attribute "Temp Inverter Out", "number"
    attribute "Temp Inverter In", "number"
    attribute "Time Remain", "number"
    attribute "Battery Status", "string"
 //  attribute "Time Remain Slave", "number"
 //  attribute "Time Remain Display", "number"
    attribute "Watts DC Out", "number"
    attribute "Watts AC In", "number"
    attribute "Watts AC Out", "number"
    attribute "Watts Slave In", "number"
    attribute "Watts Slave Out", "number"
    attribute "Last Update", "string"
    attribute "htmlTile1", "string"
      
  }

  preferences {
    input name: "unitserialno", type: "text", title: "serial number of unit:", required: true, displayDuringSetup: true
    input name: "mqttclientname", type: "text", title: "mqttclientname:", required: true, displayDuringSetup: true
    input name: "MQTTBroker", type: "text", title: "MQTT Broker Address:", required: true, displayDuringSetup: true, defaultValue: "mqtt.ecoflow.com"
    input name: "username", type: "text", title: "MQTT Username:", description: "(blank if none)", required: false, displayDuringSetup: true
    input name: "password", type: "text", title: "MQTT Password:", description: "(blank if none)", required: false, displayDuringSetup: true
    input name: "EFmodel", type: "text", title: "EF model:", description: "options are delta2 deltapro or river - no caps", required: true, displayDuringSetup: true, defaultValue: "delta"
    input name: "tempF", type: "text", title: "Temp in C or F:", description: "type C or F", required: true, displayDuringSetup: true, defaultValue: "C"
    input("logEnable", "bool", title: "Enable logging", required: true, defaultValue: true)
    input name: "updateTime", type: "number", title: "Background Data Refresh Rate (Seconds) 300 recommned - minimum is 60", required: false, defaultValue: 300, displayDuringSetup: true
    input("deltaflag", "bool", title: "flag changes", description: "Turn on to log data points that have changed since last scan" , required: true, defaultValue: false)
    input(name: "htmlTemplate1", type: "string", title: "<b>Tile Template</b>", description: "<font size='2'>Ex: [b]Remaining Minutes:[/b] \${ remainMins }V[/br]</font>", defaultValue: "");
  }

}

def installed() {
  log.info "installed dd..."
}

// Parse incoming device messages to generate events
def parse(String description) {
  log.info "updating data"
  runIn(state.SetUpdateTime, refreshdata)
  Date date = new Date();
  topic = interfaces.mqtt.parseMessage(description).topic
  topic = topic.substring(topic.lastIndexOf("/") + 1)
  payload = interfaces.mqtt.parseMessage(description).payload
  def jsonSlurper = new JsonSlurper()
  def jsonpl = jsonSlurper.parseText(payload)
  if (logEnable) log.debug payload
  def jsonObject = new JsonSlurper().parseText(payload)
  if (logEnable) log.info "updating current states"
  // scan through each JSON point - Process data 
  jsonpl.data.quotaMap.each {
    if (state."${ it.key }" != it.value) {
      oldstatevar = state."${ it.key }"
      state."${ it.key }" = it.value // load all the state values for display in device states
      if (deltaflag) { //flag battery variable changes to info log
        log.info "Battery variable>>" + it.key + "<< old value:* " + oldstatevar + " NEW VALUE: *** " + it.value
      }
    }
  }

  if (tempF == "F") { //check if temp request is C or F
    mul = 9 / 5
    adder = 32
    tunit = "F"
  } else {
    mul = 1
    adder = 0
    tunit = "C"
  }
    timerm = jsonpl.data.quotaMap."pd.remainTime"
    Integer timermHR = timerm / 60
    Integer timermMIN = timerm - timermHR * 60
     if (timerm < 0 ){
       log.info "Remain Time " + timermHR + ":" + timermMIN + " hr:mn"
     BatteryStatus ="Remain Time " + timermHR + ":" + timermMIN + " hr:mn"   
    }else{
       log.info "Charge Time " + timermHR + ":" + timermMIN + " hr:mn"
       BatteryStatus ="Charge Time " + timermHR + ":" + timermMIN + " hr:mn" 
   }
// Get JSON varaible for device outputs - case by model
    switch (EFmodel) {
       case "delta2": 
       log.info "delta2 data map routine called"
       ACOutput_Enabled = jsonpl.data.quotaMap."inv.cfgAcEnabled"
       DCOutput_Enabled = jsonpl.data.quotaMap."mppt.carState"
       USBOutput_Enabled = jsonpl.data.quotaMap."pd.dcOutState"
       LEDOutput_Enabled = null 
       sendEvent(name: "power", value: jsonpl.data.quotaMap."inv.outputWatts", unit: "w", isStateChanged: true )
       sendEvent(name: "temperature", value: jsonpl.data.quotaMap."bms_bmsStatus.temp" * mul + adder, unit: tunit, isStateChanged: true )
       sendEvent(name: "battery", value: jsonpl.data.quotaMap."bms_emsStatus.lcdShowSoc", unit: "%", isStateChanged: true )
       ProcessEvent( "Output Status AC", jsonpl.data.quotaMap."inv.cfgAcEnabled", null, true )
       ProcessEvent( "Output Status DC" , jsonpl.data.quotaMap."mppt.carState", null, true )
       ProcessEvent( "Output Status USB" , jsonpl.data.quotaMap."pd.dcOutState", null, true )
       ProcessEvent( "Output Status LED" , 0 , null, true )
       ProcessEvent( "Cycles on Master" , jsonpl.data.quotaMap."bms_bmsStatus.cycles", null, true  )
       ProcessEvent( "Cycles on Slave" ,  jsonpl.data.quotaMap."bms_slave.cycles", null, true  )
       ProcessEvent( "Fault Code mppt" ,  jsonpl.data.quotaMap."mppt.faultCode", null, true  )
       ProcessEvent( "Fault Master Cell" , jsonpl.data.quotaMap."bms_bmsStatus.bmsFault", null, true  )
       ProcessEvent( "Fault Slave Cell" ,  jsonpl.data.quotaMap."bms_slave.bmsFault", null, true  )
       ProcessEvent( "SOC Master Cell" ,  jsonpl.data.quotaMap."bms_bmsStatus.f32ShowSoc", "%", true  )
       ProcessEvent( "SOC Master Display" , jsonpl.data.quotaMap."bms_emsStatus.lcdShowSoc", "%", true )
       ProcessEvent( "SOC Slave Cell" ,  jsonpl.data.quotaMap."bms_slave.soc", "%", true  )
       ProcessEvent( "SOC Slave Display" ,  jsonpl.data.quotaMap."bms_slave.f32ShowSoc", "%", true )
       ProcessEvent( "Temp DC" ,  jsonpl.data.quotaMap."pd.carTemp"  * mul + adder, tunit, ture )
       ProcessEvent( "Temp Inverter Out" ,  jsonpl.data.quotaMap."inv.outTemp" * mul + adder, tunit, ture  )
       ProcessEvent( "Temp Master Cell" ,  jsonpl.data.quotaMap."bms_bmsStatus.temp" * mul + adder, tunit, true  )
       ProcessEvent( "Temp Mppt" ,  jsonpl.data.quotaMap."mppt.mpptTemp"* mul + adder, tunit, ture  )
       ProcessEvent( "Temp Slave Cell" ,  jsonpl.data.quotaMap."bms_slave.temp" * mul + adder, tunit, true  )
       ProcessEvent( "Time Remain" ,  jsonpl.data.quotaMap."pd.remainTime", "mins", true )
       ProcessEvent( "Battery Status" ,  BatteryStatus, null, true )
       ProcessEvent( "Watts DC Out" ,  jsonpl.data.quotaMap."pd.carWatts", "W", true )
       ProcessEvent( "Watts AC In" ,  jsonpl.data.quotaMap."inv.inputWatts", "W", true )
       ProcessEvent( "Watts AC Out" ,  jsonpl.data.quotaMap."inv.outputWatts", "W", true )
    // ProcessEvent( "Watts Master In" ,  jsonpl.data.quotaMap."bms_bmsStatus.inputWatts","W" )
   //  ProcessEvent( "Watts Master Out" ,  jsonpl.data.quotaMap."bms_bmsStatus.outputWatts", "W" )
       ProcessEvent( "Watts Slave In" ,  jsonpl.data.quotaMap."bms_slave.inputWatts", "W", true )
       ProcessEvent( "Watts Slave Out" ,  jsonpl.data.quotaMap."bms_slave.outputWatts", "W", true )
    break
    case "river":
       log.info "river data map routine called"
       ACOutput_Enabled = jsonpl.data.quotaMap."inv.cfgAcEnabled"
       DCOutput_Enabled = jsonpl.data.quotaMap."pd.carSwitch"
       USBOutput_Enabled = null
       LEDOutput_Enabled = jsonpl.data.quotaMap."pd.ledState"
       sendEvent (name: "battery" , vaule: jsonpl.data.quotaMap."pd.soc", unit: "%" )
       sendEvent (name: "power" , value: jsonpl.data.quotaMap."inv.outputWatts", unit: "W" )
       sendEvent (name: "temperature" , value: jsonpl.data.quotaMap."inv.outTemp" * mul + adder, init: tunit)
       ProcessEvent(  "Output Status AC" , jsonpl.data.quotaMap."inv.cfgAcEnabled", null, true)
       ProcessEvent(  "Output Status DC" , jsonpl.data.quotaMap."pd.carSwitch", null, true )
       ProcessEvent(  "Output Status USB" , 0 , null, true)
       ProcessEvent(  "Output Status LED" , jsonpl.data.quotaMap."pd.ledState", null, true)
       ProcessEvent(  "Cycles on Master" , jsonpl.data.quotaMap."bmsMaster.cycles", null, true )
       ProcessEvent(  "Cycles on Slave" , jsonpl.data.quotaMap."bmsSlave1.cycles", null, true)
       ProcessEvent(  "Fault Code mppt" , jsonpl.data.quotaMap."mppt.faultCode", null, true )
       ProcessEvent(  "Fault Master Cell" , jsonpl.data.quotaMap."bmsMaster.bmsFault", null, true )
       ProcessEvent(  "SOC Master Cell" , jsonpl.data.quotaMap."bmsMaster.soc", "%", true )
       ProcessEvent(  "SOC Slave Cell" , jsonpl.data.quotaMap."bmsSlave1.soc", "%", true  )
       ProcessEvent(  "Temp DC" , value: jsonpl.data.quotaMap."pd.carTemp"  * mul + adder,  tunit, true )
       ProcessEvent(  "Temp Inverter Out" , jsonpl.data.quotaMap."inv.outTemp" * mul + adder, tunit, true )
       ProcessEvent(  "Temp Inverter In" , jsonpl.data.quotaMap."inv.inTemp" * mul + adder, tunit, true )
       ProcessEvent(  "Temp Master Cell" , jsonpl.data.quotaMap."bmsMaster.temp" * mul + adder, tunit, true )
//     ProcessEvent(  "Temp Mppt" , jsonpl.data.quotaMap."mppt.mpptTemp"* mul + adder, tunit, true )
       ProcessEvent(  "Temp Slave Cell" , jsonpl.data.quotaMap."bmsSlave1.temp" * mul + adder, tunit, true )
       ProcessEvent(  "Time Remain" , jsonpl.data.quotaMap."pd.remainTime", unit: "mins", true )
       ProcessEvent( "Battery Status" ,  BatteryStatus, null, true )
       ProcessEvent(  "Watts DC Out" , jsonpl.data.quotaMap."pd.carWatts", unit: "W", true )
       ProcessEvent(  "Watts AC In" , jsonpl.data.quotaMap."inv.inputWatts", unit: "W", true )
       ProcessEvent(  "Watts AC Out" , jsonpl.data.quotaMap."inv.outputWatts", unit: "W", true )
 //    ProcessEvent(  "Watts Master In" , jsonpl.data.quotaMap."bmsMaster.inputWatts", "W", true )
 //    ProcessEvent(  "Watts Master Out" , jsonpl.data.quotaMap."bmsMaster.outputWatts", "W", true )
//     ProcessEvent(  "Watts Slave In" , jsonpl.data.quotaMap."bmsSlave.inputWatts", "W", true )
//     ProcessEvent(  "Watts Slave Out" , jsonpl.data.quotaMap."bmsSlave.outputWatts", "W", true  )
    break 
    case "deltapro":
        log.info "deltapro data map routine called"
        ACOutput_Enabled = jsonpl.data.quotaMap."inv.cfgAcEnabled"
        DCOutput_Enabled = jsonpl.data.quotaMap."mppt.carState"
        USBOutput_Enabled = null
        LEDOutput_Enabled = null
        sendEvent(name: "battery" , value: jsonpl.data.quotaMap."bmsMaster.soc", unit: "%", isStateChanged: true )
        sendEvent (name: "power" , value: jsonpl.data.quotaMap."inv.outputWatts", unit: "W", isStateChanged: true )
        sendEvent (name: "temperature" , value: jsonpl.data.quotaMap."bmsMaster.temp" * mul + adder, unit: tunit, isStateChanged: true )
        ProcessEvent(  "Output Status AC" , jsonpl.data.quotaMap."inv.cfgAcEnabled", null, true )
        ProcessEvent(  "Output Status DC" , jsonpl.data.quotaMap."mppt.carState", null, true  )
        ProcessEvent(  "Output Status USB" , 0 , null, true )
        ProcessEvent(  "Output Status LED" , 0 , null, true )
        ProcessEvent(  "Cycles on Master" , jsonpl.data.quotaMap."bmsMaster.cycles", null, true )
        ProcessEvent(  "Cycles on Slave" , jsonpl.data.quotaMap."bmsSlave1.cycles", null, true )
        ProcessEvent(  "Fault Code mppt" , jsonpl.data.quotaMap."mppt.faultCode", null, true )
        ProcessEvent(  "Fault Master Cell" , jsonpl.data.quotaMap."bmsMaster.bmsFault", null, true )
        ProcessEvent(  "Fault Slave Cell" , jsonpl.data.quotaMap."bmsSlave1.bmsFault", null, true )
        ProcessEvent(  "SOC Master Cell" , jsonpl.data.quotaMap."bmsMaster.soc", "%",  true )
//      ProcessEvent(  "SOC Master Display" , jsonpl.data.quotaMap."bmsMaster.fShowSoc", "%",  true )
        ProcessEvent(  "SOC Slave Cell" , jsonpl.data.quotaMap."bmsSlave1.soc", "%",  true )
 //     ProcessEvent(  "SOC Slave Display" , jsonpl.data.quotaMap."bmsSlave.fShowSoc",  "%", true )
        ProcessEvent(  "Temp DC" , jsonpl.data.quotaMap."pd.carTemp"  * mul + adder, tunit, true )
        ProcessEvent(  "Temp Inverter" , jsonpl.data.quotaMap."inv.outTemp" * mul + adder, tunit, true )
        ProcessEvent(  "Temp Master Cell" , jsonpl.data.quotaMap."bmsMaster.temp" * mul + adder, tunit, true )
        ProcessEvent(  "Temp Mppt" , jsonpl.data.quotaMap."mppt.mpptTemp" * mul + adder, tunit, true )
        ProcessEvent(  "Temp Slave Cell" , jsonpl.data.quotaMap."bmsSlave1.temp" * mul + adder, tunit, true )
        ProcessEvent( "Time Remain" ,  jsonpl.data.quotaMap."pd.remainTime", "mins", true )
        ProcessEvent( "Battery Status" ,  BatteryStatus, null, true )
        ProcessEvent(  "Watts DC Out" , jsonpl.data.quotaMap."pd.carWatts", "W", true )
        ProcessEvent(  "Watts AC In" , jsonpl.data.quotaMap."inv.inputWatts", "W", true )
        ProcessEvent(  "Watts AC Out" , jsonpl.data.quotaMap."inv.outputWatts", "W", true )
   //   ProcessEvent(  "Watts Master In" , jsonpl.data.quotaMap."bmsMaster.inputWatts", "W", true )
  //    ProcessEvent(  "Watts Master Out" , jsonpl.data.quotaMap."bmsMaster.outputWatts", "W", true )
        ProcessEvent(  "Watts Slave In" , jsonpl.data.quotaMap."bmsSlave1.inputWatts", "W", true )
        ProcessEvent(  "Watts Slave Out" , jsonpl.data.quotaMap."bmsSlave1.outputWatts", "W", true )
    break
    default:
       DCOutput_Enabled = null
       USBOutput_Enabled = null
       LEDOutput_Enabled = null
       log.info "model type not found - model input currently set as " + EFmodel
   }
   sendEvent(name: "Last Update", value: date, isStateChanged: true)
  //check if output states have changed and update the child's state if required.
  if (ACOutput_Enabled != state.ACoutput) {
    state.cdtype = 1
    def cd = fetchChild("Switch")
    if (ACOutput_Enabled == 1) {
      cd.parse([[name: "switch", value: "on", descriptionText: "AC Switch was turned on"]])
      state.ACoutput = 1
      state.ACoutputSTR = "Enabled"
    } else {
      cd.parse([[name: "switch", value: "off", descriptionText: "AC Switch was turned off"]])
      state.ACoutput = 0
      state.ACoutputSTR = "OFF"
    }
  }
  if (DCOutput_Enabled != state.DCoutput) {
    state.cdtype = 2
    def cd = fetchChild("Switch")
    if (DCOutput_Enabled == 1) {
      cd.parse([[name: "switch", value: "on", descriptionText: "DC Switch was turned on"]])
      state.DCoutput = 1
      state.DCoutputSTR = "Enabled"
    } else {
      cd.parse([[name: "switch", value: "off", descriptionText: "DC Switch was turned off"]])
      state.DCoutput = 0
      state.DCoutputSTR = "OFF"
    }
  }
  if (USBOutput_Enabled != NULL) {
    if (USBOutput_Enabled != state.USBoutput) {
      state.cdtype = 3
      def cd = fetchChild("Switch")
      if (USBOutput_Enabled == 1) {
        cd.parse([[name: "switch", value: "on", descriptionText: "USB Switch was turned on"]])
        state.USBoutput = 1
        state.USBoutputSTR = "Enabled"
      } else {
        cd.parse([[name: "switch", value: "off", descriptionText: "USB Switch was turned off"]])
        state.USBoutput = 0
        state.USBoutputSTR = "OFF"
      }
    }
  }
  if (LEDOutput_Enable != NULL) {
    if (LEDOutput_Enabled != state.LEDoutput) {
      state.cdtype = 4
      def cd = fetchChild("Switch")
      if (LEDOutput_Enabled == 1) {
        cd.parse([[name: "switch", value: "on", descriptionText: "LED Light was turned on"]])
        state.LEDoutput = 1
        state.LEDoutputSTR = "Enabled"
      } else {
        cd.parse([[name: "switch", value: "off", descriptionText: "LED light was turned off"]])
        state.LEDoutput = 0
        state.LEDoutputSTR = "OFF"
      }
    }
  }
  if (logEnable) log.info "current states updated"
  state.reloadData = 1
  UpdateTile()
  log.info "data update complete"
}
//refresh data by sending mqtt command requesting data update
def refreshdata() {
  if (state.refreshpayload == null) {
    log.info "model type not found - model input currently set as " + EFmodel
  }
  ptopic = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/get"
  interfaces.mqtt.publish(ptopic, state.refreshpayload)
}

def publishMsg(String s) {
  //   Not a working feature
  if (logEnable) log.debug "Sent this: ${s} to ${settings?.topicPub} - QOS Value: ${settings?.QOS.toInteger()} - Retained: ${settings?.retained}"
  interfaces.mqtt.publish(settings?.topicPub, s, settings?.QOS.toInteger(), settings?.retained)
}

def updated() {
  log.info "update running"
  if (logEnable) log.info "Updated..."
  initialize()
}

def uninstalled() {
  //   Not a working feature   
  if (logEnable) log.info "Disconnecting from mqtt"
  interfaces.mqtt.disconnect()
  log.info "MQTT disconnected"

}
def initialize() {
  if (logEnable) log.info "initialize"
  if (logEnable) runIn(900, logsOff)
  if (deltaflag) runIn(900, deltaflagOFF)
  device.updateSetting("Deltaflag", [value: "false", type: "bool"])
  switch (EFmodel) {
  case "delta2":
    state.AConPayload = /{"from":"Android","id":"498321003","moduleType":5,"operateType":"acOutCfg","params":{"out_voltage":-1,"out_freq":255,"xboost":255,"enabled":1},"version":"1.0"}/
    state.ACoffPayload = /{"from":"Android","id":"498321003","moduleType":5,"operateType":"acOutCfg","params":{"out_voltage":-1,"out_freq":255,"xboost":255,"enabled":0},"version":"1.0"}/
    state.DConPayload = /{"from":"Android","id":"498321003","moduleType":5,"operateType":"mpptCar","params":{"enabled":1},"version":"1.0"}/
    state.DCoffPayload = /{"from":"Android","id":"498321003","moduleType":5,"operateType":"mpptCar","params":{"enabled":0},"version":"1.0"}/
    state.USBonPayload = /{"from":"Android","id":"498321003","moduleType":1,"operateType":"dcOutCfg","params":{"enabled":1},"version":"1.0"}/
    state.USBoffPayload = /{"from":"Android","id":"498321003","moduleType":1,"operateType":"dcOutCfg","params":{"enabled":0},"version":"1.0"}/
    state.LEDonPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 00,"state": 1},"version": "1.0"}/
    state.LEDoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 00,"state": 0},"version": "1.0"}/
    state.refreshpayload = /{"from":"Android","id":"380541001","moduleType":0,"operateType":"latestQuotas","params":{},"version":"1.0"}/
    break
  case "river":
    state.AConPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 66,"enabled": 1},"version":"1.0"}/
    state.ACoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 66,"enabled": 0},"version":"1.0"}/
    state.DConPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 34,"enabled": 1},"version": "1.0"}/
    state.DCoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 34,"enabled": 0},"version": "1.0"}/
    state.USBonPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 72,"enabled": 1},"version": "1.0"}/
    state.USBoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 72,"enabled": 0},"version": "1.0"}/
    state.LEDonPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 35,"state": 1},"version": "1.0"}/
    state.LEDoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 35,"state": 0},"version": "1.0"}/
    state.refreshpayload = /{"from":"Android","id":"380541001","moduleType":0,"operateType":"latestQuotas","params":{},"version":"1.0"}/
    break
  case "deltapro":
    state.AConPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 66,"enabled": 1},"version":"1.0"}/
    state.ACoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 66,"enabled": 0},"version":"1.0"}/
    state.DConPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 81,"enabled": 1},"version": "1.0"}/
    state.DCoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 81,"enabled": 0},"version": "1.0"}/
    state.USBonPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 72,"enabled": 1},"version": "1.0"}/
    state.USBoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 72,"enabled": 0},"version": "1.0"}/
    state.LEDonPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 00,"state": 1},"version": "1.0"}/
    state.LEDoffPayload = /{"from": "Android","id": "498321003","moduleType": 0,"operateType":"TCP","params": {"id": 00,"state": 0},"version": "1.0"}/
    state.refreshpayload = /{"from":"Android","id":"380541001","moduleType":0,"operateType":"latestQuotas","params":{},"version":"1.0"}/
    break
  default:
    state.AConPayload = null
    state.ACoffPayload = null
    state.DConPayload = null
    state.DCoffPayload = null
    state.USBonPayload = null
    state.USBoffPayload = null
    state.LEDonPayload = null
    state.LEDoffPayload = null
    state.refreshpayload = null
    log.info "model type not found - model input currently set as " + EFmodel
  }
  if (settings.updateTime < 60) {
    state.SetUpdateTime = 60
  } else {
    state.SetUpdateTime = settings.updateTime
  }
  state.reloadData = 0
  log.info "reset initialize flag=" + state.reloadData
  mqttConnect()
  refreshdata()
}

//set up mqtt server connection
def mqttConnect() {
  try {
    if (settings?.retained == null) settings?.retained = false
    if (settings?.QOS == null) setting?.QOS = "0"
    //open connection
    mqttbroker = "ssl://" + settings?.MQTTBroker + ":8883"
    settings?.topicSub = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/get_reply"
    if (logEnable) log.info "broker " + mqttbroker
    if (logEnable) log.info "client " + mqttclientname
    if (logEnable) log.info "username   " + username
    if (logEnable) log.info "password " + password
    interfaces.mqtt.connect(mqttbroker,
      mqttclientname,
      username,
      password,
      lastWillQos: 0,
      lastWillMessage: "offline",
      lastWillRetain: true,
      tlsVersion: 1.2)

    if (logEnable) log.info "mqtt.con" + mqttConnect
    //give it a chance to start
    pauseExecution(1000)
    //log.info "Connection established"
    if (logEnable) log.debug "Subscribed to: ${settings?.topicSub}"
    log.info settings?.topicSub
    interfaces.mqtt.subscribe(settings?.topicSub)
  } catch (e) {
    if (logEnable) log.debug "Initialize error: ${e.message}"
  }
}

def mqttClientStatus(String status) {
  log.info "mqttClientStatus dd"
  if (!status.contains("succeeded")) {
    try {
      interfaces.mqtt.disconnect()
    } catch (e) {}
    if (logEnable) log.debug "Broker: ${status} Will restart in 15 seconds"
    runIn(15, mqttConnect)
  }
}

def logsOff() {
  log.warn "Debug logging disabled."
  device.updateSetting("logEnable", [value: "false", type: "bool"])
}

def deltaflagOFF() {
  log.warn "Deltaflag disabled."
  device.updateSetting("Deltaflag", [value: "false", type: "bool"])
}

//demo custom commands
void componentRefresh(cd) {
  log.info "received refresh request from ${cd.displayName}"
  refreshdata()
}

//when switch state changes are requested - update the child and send MQTT commmand to change device - 
// wait for 5 seconds and then request mqtt data refresh
void ACSwitchON() {
  state.cdtype = 1
  def cd = fetchChild("Switch")
  log.info "ACSwitchON cd on=" + cd
  cd.parse([[name: "switch", value: "on", descriptionText: "AC Switch was turned on"]])
  log.info "AC switch on request"
  ptopic = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/set"
  log.info "topic=" + ptopic + " payload=" + state.AConPayload
  interfaces.mqtt.publish(ptopic, state.AConPayload)
  pauseExecution(5000)
  refreshdata()
}

void ACSwitchOFF() {
  state.cdtype = 1
  def cd = fetchChild("Switch")
  log.info "ACSwitchOFF cd off=" + cd
  cd.parse([
    [name: "switch", value: "off", descriptionText: "AC Switch was turned off"]])
  ptopic = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/set"
  log.info "topic=" + ptopic + " payload=" + state.ACoffPayload
  interfaces.mqtt.publish(ptopic, state.ACoffPayload)
  pauseExecution(5000)
  refreshdata()
}
void DCSwitchON() {
  state.cdtype = 2
  def cd = fetchChild("Switch")
  cd.parse([
    [name: "switch", value: "on", descriptionText: "DC Switch was turned on"]])
  ptopic = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/set"
  log.info "topic=" + ptopic + " payload=" + state.DConPayload
  interfaces.mqtt.publish(ptopic, state.DConPayload)
  pauseExecution(5000)
  refreshdata()

}
void DCSwitchOFF() {
  state.cdtype = 2
  def cd = fetchChild("Switch")
  log.info "DCSwitchOFF cd off=" + cd
  cd.parse([
    [name: "switch", value: "off", descriptionText: "DC Switch was turned off"]])
  log.info "DC switch off request"
  ptopic = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/set"
  log.info "topic=" + ptopic + " payload=" + state.DCoffPayload
  interfaces.mqtt.publish(ptopic, state.DCoffPayload)
  pauseExecution(5000)
  refreshdata()

}
void USBSwitchON() {
  if (EFmodel == "delta2") {
    state.cdtype = 3
    def cd = fetchChild("Switch")
    log.info "USBSwitchON cd on=" + cd
    cd.parse([
      [name: "switch", value: "on", descriptionText: "USB Switch was turned on"]])
    log.info "USB switch on request"
    ptopic = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/set"
    log.info "topic=" + ptopic + " payload=" + state.USBonPayload
    interfaces.mqtt.publish(ptopic, state.USBonPayload)
    pauseExecution(5000)
    refreshdata()
  } else {
    log.info "USB Switch not supported due to model selection"
  }
}
void USBSwitchOFF() {
  if (EFmodel == "delta2") {
    state.cdtype = 3
    def cd = fetchChild("Switch")
    log.info "USBSwitchOFF cd off=" + cd
    cd.parse([
      [name: "switch", value: "off", descriptionText: "USB Switch was turned off"]])
    log.info "USB switch off request"
    ptopic = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/set"
    log.info "topic=" + ptopic + " payload=" + state.USBoffPayload
    interfaces.mqtt.publish(ptopic, state.USBoffPayload)
    pauseExecution(5000)
    refreshdata()
  } else {
    log.info "USB Switch not supported due to model selection"
  }
}

void LEDSwitchON() {
  if (EFmodel == "river") {
    state.cdtype = 4
    def cd = fetchChild("Switch")
    log.info "LEDSwitchOFF cd on=" + cd
    cd.parse([
      [name: "switch", value: "on", descriptionText: "LED Light was turned on"]])
    log.info "LED light on request"
    ptopic = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/set"
    log.info "topic=" + ptopic + " payload=" + state.LEDonPayload
    interfaces.mqtt.publish(ptopic, state.LEDonPayload)
    pauseExecution(5000)
    refreshdata()
  } else {
    log.info "LED Switch not supported due to model selection"
  }
}
void LEDSwitchOFF() {
  if (EFmodel == "river") {
    state.cdtype = 4
    def cd = fetchChild("Switch")
    log.info "LEDSwitchOFF cd off=" + cd
    cd.parse([
      [name: "switch", value: "off", descriptionText: "LED Light was turned off"]])
    log.info "LED light off request"
    ptopic = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/set"
    log.info "topic=" + ptopic + " payload=" + state.LEDoffPayload
    interfaces.mqtt.publish(ptopic, state.LEDoffPayload)
    pauseExecution(5000)
    refreshdata()
  } else {
    log.info "LED Switch not supported due to model selection"
  }
}

//get data for switches 1, 2, and 3. If child1 does not exist - create all of them.
def fetchChild(String type) {
  String thisId = device.id
  log.info "fetchChild run >> thisID=" + thisId + " cdtype=" + state.cdtype
  def cd = getChildDevice("${thisId}${state.cdtype}-Switch")
  log.info "fetchchild CD=" + cd
  if (cd == null) {
    cd = addChildDevice("hubitat", "Generic Component Switch", "${thisId}1-Switch", [name: "EF AC Switch", isComponent: true])
    cd1 = addChildDevice("hubitat", "Generic Component Switch", "${thisId}2-Switch", [name: "EF DC Switch", isComponent: true])
    if (EFmodel == "delta2") {
       cd2 = addChildDevice("hubitat", "Generic Component Switch", "${thisId}3-Switch", [name: "EF USB Switch", isComponent: true])
    }
    if (EFmodel == "river") {
      cd3 = addChildDevice("hubitat", "Generic Component Switch", "${thisId}4-Switch", [name: "EF LED Switch", isComponent: true])
    }
    log.info "type=" + type + " thisid=" + thisId + "displayname=" + device.displayName
    List < Map > defaultValues = []
    cd.parse(defaultValues)
  }
  return cd
}

// child has requested state change to ON - determine what child is asking for change and run sequence to update device
void componentOn(cd) {
  getChildDevice(cd.deviceNetworkId).parse([
    [name: "switch", value: "on", descriptionText: "${cd.displayName} was turned on"]])
  switch (cd.displayName) {
  case "EF AC Switch":
    ACSwitchON()
    break
  case "EF USB Switch":
    USBSwitchON()
    break
  case "EF DC Switch":
    DCSwitchON()
    break
  case "EF LED Switch":
    LEDSwitchON()
    break
  }
}

// child has requested state change to OFF - determine what child is asking for change and run sequence to update device
void componentOff(cd) {
  getChildDevice(cd.deviceNetworkId).parse([
    [name: "switch", value: "off", descriptionText: "${cd.displayName} was turned off"]])
  switch (cd.displayName) {
  case "EF AC Switch":
    ACSwitchOFF()
    break
  case "EF USB Switch":
    USBSwitchOFF()
    break
  case "EF DC Switch":
    DCSwitchOFF()
    break
  case "EF LED Switch":
    LEDSwitchOFF()
    break
  }
}
// Process data to check against current state value and then send an event if it has changed
def ProcessEvent(Variable, Value, Unit = null, ForceEvent = false) {
  if ((state.
      "${ Variable }" != Value) || (ForceEvent == true)) {
    state.
    "${ Variable }" = Value
    if (Unit != null) {
       sendEvent(name: "${ Variable }", value: Value, unit: Unit, isStateChanged: true)
    } else {
       sendEvent(name: "${ Variable }", value: Value, isStateChanged: true)
    }
  }
}

private void UpdateTile() {
  def val = ""
  // Create special compound/html tile
  val = "DC Temps:" + device.currentValue("Temp DC") + " Mppt Temp:" + device.currentValue("Temp Mppt") + " Master Temp:" + device.currentValue("Temp Master Cell") + " Slave Temp:" + device.currentValue("Temp Slave Cell").toString()
  val1 = "<B>DC Temp:</B>" + device.currentValue("Temp DC") + " <B>Mppt Temp:</B>" + device.currentValue("Temp Mppt") + " <B>Master Temp:</B>" + device.currentValue("Temp Master Cell") + " <B>Slave Temp:</B>" + device.currentValue("Temp Slave Cell").toString()
     if( device.currentValue( "htmlTile1" ).toString() != val1 ){
        sendEvent( name: "htmlTile1", value: val1 )
     }
}

